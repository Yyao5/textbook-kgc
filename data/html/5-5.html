<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2299.4">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Times}
    span.s1 {font: 10.0px Helvetica}
    span.s2 {color: #000066}
    span.s3 {font: 10.0px Courier}
  </style>
</head>
<body>
<p class="p1"><span class="s1">Performance isolation </span>is a critical condition for quality-of-service (QoS) guarantees in shared computing</p>
<p class="p1">environments. Indeed, if the run-time behavior of an application is affected by other applications running</p>
<p class="p1">concurrently and, thus, is competing for CPU cycles, cache, main memory, and disk and network</p>
<p class="p1">access, it is rather difficult to predict the completion time. Moreover, it is equally difficult to optimize</p>
<p class="p1">the application. Several operating systems, including <span class="s1">Linux</span>/RK [<span class="s2">270</span>], QLinux [<span class="s2">343</span>], and SILK [<span class="s2">44</span>],</p>
<p class="p1">support some performance isolation, but problems still exist because one has to account for all resources</p>
<p class="p1">used and to distribute the overhead for different system activities, including context switching and</p>
<p class="p1">paging, to individual users – a problem often described as <span class="s1">QoS crosstalk </span>[<span class="s2">348</span>].</p>
<p class="p1"><span class="s1">Processor virtualization </span>presents multiple copies of the same processor or core onmulticore systems.</p>
<p class="p1">The code is executed directly by the hardware, whereas <span class="s1">processor emulation </span>presents a model of another</p>
<p class="p1">hardware system in which instructions are “emulated” in software more slowly than virtualization. An</p>
<p class="p1">example is Microsoft’s VirtualPC, which could run on chip sets other than the <span class="s3">x86 </span>family. It was used</p>
<p class="p1">on <span class="s1">Mac </span>hardware until Apple adopted Intel chips.</p>
<p class="p1">Traditional operating systems multiplex multiple processes or threads, whereas a virtualization supported</p>
<p class="p1">by a VMM multiplexes full operating systems.Obviously, there is a performance penalty because</p>
<p class="p1">an OS is considerably more heavyweight than a process and the overhead of context switching is larger.</p>
<p class="p1">A VMM executes directly on the hardware a subset of frequently used machine instructions generated by the application and emulates privileged instructions, including device I/O requests. The subset of</p>
<p class="p1">the instructions executed directly by the hardware includes arithmetic instructions, memory access, and</p>
<p class="p1">branching instructions.</p>
<p class="p1">Operating systems use process abstraction not only for resource sharing but also to support isolation.</p>
<p class="p1">Unfortunately, this is not sufficient from a security perspective. Once a process is compromised, it is</p>
<p class="p1">rather easy for an attacker to penetrate the entire system. On the other hand, the software running on</p>
<p class="p1">a virtual machine has the constraints of its own dedicated hardware; it can only access virtual devices</p>
<p class="p1">emulated by the software. This layer of software has the potential to provide a level of isolation nearly</p>
<p class="p1">equivalent to the isolation presented by two different physical systems. Thus, the virtualization can be</p>
<p class="p1">used to improve security in a cloud computing environment.</p>
<p class="p1">A VMM is a much simpler and better specified system than a traditional operating system. For</p>
<p class="p1">example, the <span class="s1">Xen </span>VMM discussed in Section <span class="s2">5.8 </span>has approximately 60,000 lines of code, whereas</p>
<p class="p1">the <span class="s1">Denali </span>VMM [<span class="s2">372</span>] has only about half that, or 30,000 lines of code. The security vulnerability</p>
<p class="p1">of VMMs is considerably reduced because the systems expose a much smaller number of privileged</p>
<p class="p1">functions. For example, the <span class="s1">Xen </span>VMM can be accessed through 28 hypercalls, whereas a standard</p>
<p class="p1"><span class="s1">Linux </span>allows hundreds (e.g., <span class="s1">Linux </span>2.6.11 allows 289 system calls). In addition to a plethora of system</p>
<p class="p1">calls, a traditional operating system supports special devices (e.g., <span class="s3">/dev/kmem</span>) and many privileged</p>
<p class="p1">programs from a third party (e.g., <span class="s3">sendmail </span>and <span class="s3">sshd</span>).</p>
</body>
</html>
